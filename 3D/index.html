<!doctype html>
<html lang="fr">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Babylon.js â€“ SphÃ¨re 3D</title>
    <style>
        html, body { height: 100%; margin: 0; overflow: hidden; background: #0f1115; }
        #renderCanvas { width: 100%; height: 100%; touch-action: none; }
        .ui {
            position: absolute; left: 50%; bottom: 18px; transform: translateX(-50%);
            background: rgba(0,0,0,.45); backdrop-filter: blur(6px);
            border-radius: 14px; padding: 10px 16px; box-shadow: 0 6px 24px rgba(0,0,0,.35);
            color: #eaeaea; font-family: system-ui, sans-serif;
            display: flex; align-items: center; gap: 12px;
        }
        input[type="range"] { width: 240px; }
        label { font-size: 14px; }
    </style>
</head>
<body>
<canvas id="renderCanvas"></canvas>

<!--div class="ui">
  <label for="rot">Rotation (Â°)</label>
  <input id="rot" type="range" min="-180" max="180" step="1" value="0" />
  <span id="deg">0Â°</span>
</div-->

<!-- Babylon.js CDN -->
<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
<script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>


<script>

    const canvas = document.getElementById("renderCanvas");
    const engine = new BABYLON.Engine(canvas, true);

    const MODEL_URL = "./models/earth2.glb"; // Ton modÃ¨le Blender exportÃ©
    const MODEL_URLN = "./models/nuage.glb"; // Ton modÃ¨le Blender exportÃ©

    const createScene = async function () {
        const scene = new BABYLON.Scene(engine);
        scene.clearColor = new BABYLON.Color3(0.06, 0.07, 0.09);

        // CamÃ©ra orbitale (drag = rotation, molette = zoom)
        const camera = new BABYLON.ArcRotateCamera("camera",
            BABYLON.Tools.ToRadians(90), BABYLON.Tools.ToRadians(60),
            3, BABYLON.Vector3.Zero(), scene);
        camera.attachControl(canvas, true);
        camera.wheelPrecision = 50;
        camera.minZ = 0.1;
        camera.lowerRadiusLimit = 1;
        camera.upperRadiusLimit = 15;

        // LumiÃ¨res
        const light1 = new BABYLON.HemisphericLight("h1", new BABYLON.Vector3(0, 1, 0), scene);
        light1.intensity = 0.7;
        const light2 = new BABYLON.DirectionalLight("dir", new BABYLON.Vector3(-1, -2, -1), scene);
        light2.intensity = 1.2;

        // Sol (optionnel)

        // Ombres
        const shadowGenerator = new BABYLON.ShadowGenerator(2048, light2);
        shadowGenerator.useBlurExponentialShadowMap = true;

        //Background
        scene.environmentTexture = new BABYLON.HDRCubeTexture(
            "models/space.hdr",
            scene,
            512
        );

        scene.createDefaultSkybox(scene.environmentTexture, true, 1000);

        // Chargement du modÃ¨le GLB TERRE
        let rootMesh;
        try {
            const result = await BABYLON.SceneLoader.ImportMeshAsync("", "models/", "earth2.glb", scene);
            rootMesh = result.meshes[0];
            rootMesh.position.y = 0;
            rootMesh.scaling = new BABYLON.Vector3(1, 1, 1);
            shadowGenerator.addShadowCaster(rootMesh);
            console.log("ModÃ¨les chargÃ©s âœ…");
        } catch (err) {
            console.error("Erreur de chargement âŒ", err);
            // Fallback sphÃ¨re
            rootMesh = BABYLON.MeshBuilder.CreateSphere("sphere", { diameter: 2, segments: 64 }, scene);
            const mat = new BABYLON.StandardMaterial("mat", scene);
            mat.diffuseColor = new BABYLON.Color3(0.23, 0.63, 1);
            mat.specularPower = 64;
            rootMesh.material = mat;
        }

        //Nuage
        let sphere;
        try {
            const resultN = await BABYLON.SceneLoader.ImportMeshAsync("", "models/", "nuage.glb", scene);

            // Chercher un vrai mesh (pas un transform node)
            sphere = resultN.meshes.find(m => m.geometry != null);

            if (!sphere) {
                throw new Error("Aucun mesh valide dans nuage.glb");
            }

            // Material
            const mat = new BABYLON.StandardMaterial("matHover", scene);
            mat.diffuseColor = new BABYLON.Color3(0.7, 0.7, 0.7);
            sphere.material = mat;

            // Transformations
            sphere.scaling = new BABYLON.Vector3(0.04, 0.04, 0.04);
            sphere.rotation = new BABYLON.Vector3(0, 2, 0);
            sphere.position.y = 0.80;
            sphere.position.x = 0.80;

            shadowGenerator.addShadowCaster(sphere);

            console.log("Gros Nuage chargÃ© âœ…");
            console.log("Mesh utilisÃ© :", sphere);
            console.log("Bounding info :", sphere.getBoundingInfo().boundingBox);

        } catch (err) {
            console.error("Erreur de chargement âŒ", err);
        }

        const advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");

        const rect = new BABYLON.GUI.Rectangle();
        rect.width = "200px";
        rect.height = "30px";
        rect.cornerRadius = 20;
        rect.color = "white";
        rect.thickness = 2;
        rect.background = "rgba(0,0,0,0.5)";

        const textBlock = new BABYLON.GUI.TextBlock();
        textBlock.text = "La Neige au Quebec";
        textBlock.color = "white";
        textBlock.fontSize = 10;

        rect.addControl(textBlock);
        advancedTexture.addControl(rect);

        // Attacher au mesh
        rect.linkWithMesh(sphere);
        rect.linkOffsetY = -40; // dÃ©calage vers le haut
        advancedTexture.addControl(rect);
        rect.isVisible = false;

        //Tornade
        let Cone;

        try {
            const resultN = await BABYLON.SceneLoader.ImportMeshAsync("", "models/", "cone.glb", scene);

            // Chercher un vrai mesh (pas un transform node)
            Cone = resultN.meshes.find(m => m.geometry != null);

            if (!Cone) {
                throw new Error("Aucun mesh valide dans nuage.glb");
            }

            // Material
            const mat = new BABYLON.StandardMaterial("matHover", scene);
            mat.diffuseColor = new BABYLON.Color3(0.051, 0.051, 0.051);
            Cone.material = mat;

            // Transformations
            Cone.scaling = new BABYLON.Vector3(0.17, 0.05, 0.17);
            Cone.rotation = new BABYLON.Vector3(- 2.4, 0, 0);
            Cone.position.y = 0.75;
            Cone.position.z = 0.75;

            shadowGenerator.addShadowCaster(Cone);

            console.log("Gros Cone chargÃ© âœ…");
            console.log("Mesh utilisÃ© :", Cone);
            console.log("Bounding info :", Cone.getBoundingInfo().boundingBox);

        } catch (err) {
            console.error("Erreur de chargement âŒ", err);
        }

        const advancedTexturet = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
        const rectt = new BABYLON.GUI.Rectangle();

        rectt.width = "200px";
        rectt.height = "30px";
        rectt.cornerRadius = 20;
        rectt.color = "white";
        rectt.thickness = 2;
        rectt.background = "rgba(0,0,0,0.5)";

        const textBlockt = new BABYLON.GUI.TextBlock();
        textBlockt.text = "Ouragan Melissa";
        textBlockt.color = "white";
        textBlockt.fontSize = 10;

        rectt.addControl(textBlockt);
        advancedTexturet.addControl(rectt);

        // Attacher au mesh
        rectt.linkWithMesh(Cone);
        rectt.linkOffsetY = -40; // dÃ©calage vers le haut
        advancedTexturet.addControl(rectt);
        rectt.isVisible = false;



        //flÃ¨che
        let flch;
        try {
            const resultN = await BABYLON.SceneLoader.ImportMeshAsync("", "models/", "flch.glb", scene);

            // Chercher un vrai mesh (pas un transform node)
            flch = resultN.meshes.find(m => m.geometry != null);

            if (!flch) {
                throw new Error("Aucun mesh valide dans flch.glb");
            }

            // Material
            const mat = new BABYLON.StandardMaterial("matHover", scene);
            mat.diffuseColor = new BABYLON.Color3(0, 1, 0);
            flch.material = mat;

            // Transformations
            flch.scaling = new BABYLON.Vector3(0.04, 0.04, 0.04);
            flch.rotation = new BABYLON.Vector3(0, 2, 0);
            flch.position.y = 1.20;
            flch.position.x = 0;

            shadowGenerator.addShadowCaster(flch);

            console.log("flÃ¨che chargÃ© âœ…");
            console.log("Mesh utilisÃ© :", flch);
            console.log("Bounding info :", flch.getBoundingInfo().boundingBox);

        } catch (err) {
            console.error("Erreur de chargement âŒ", err);
        }

        const advancedTexturef = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");

        const rectf = new BABYLON.GUI.Rectangle();
        rectf.width = "200px";
        rectf.height = "30px";
        rectf.cornerRadius = 20;
        rectf.color = "white";
        rectf.thickness = 2;
        rectf.background = "rgba(0,0,0,0.5)";

        const textBlockf = new BABYLON.GUI.TextBlock();
        textBlockf.text = "Pression AtmosphÃ©rique";
        textBlockf.color = "white";
        textBlockf.fontSize = 10;

        rectf.addControl(textBlockf);
        advancedTexturef.addControl(rectf);

        // Attacher au mesh
        rectf.linkWithMesh(flch);
        rectf.linkOffsetY = -40; // dÃ©calage vers le haut
        advancedTexturef.addControl(rectf);
        rectf.isVisible = false;




        // Slider de rotation
        //const rotInput = document.getElementById("rot");
        //const degLabel = document.getElementById("deg");
        //rotInput.addEventListener("input", () => {
        //  const deg = parseFloat(rotInput.value);
        //  degLabel.textContent = `${deg}Â°`;
        //  rootMesh.rotation.y = BABYLON.Tools.ToRadians(deg);
        //});




        // MA GROSSE SPHERE POUR MES TEST !!!


        const actionManager = new BABYLON.ActionManager(scene);
        sphere.actionManager = actionManager;

        // ðŸŒŸ Effet visuel au survol
        let originalColor = null;
        sphere.actionManager.registerAction(
            new BABYLON.ExecuteCodeAction(
                BABYLON.ActionManager.OnPointerOverTrigger,
                function () {
                    if (sphere.material && !originalColor) {
                        sphere.scaling = new BABYLON.Vector3(0.045, 0.045, 0.045);
                        originalColor = sphere.material.diffuseColor.clone();
                        sphere.material.diffuseColor = new BABYLON.Color3(1, 0.5, 0.1); // orange sur survol
                        document.body.style.cursor = "pointer"; // curseur main
                        rect.isVisible = true;
                    }
                }
            )
        );

        // ðŸ”„ Retour Ã  la couleur dâ€™origine quand on quitte
        sphere.actionManager.registerAction(
            new BABYLON.ExecuteCodeAction(
                BABYLON.ActionManager.OnPointerOutTrigger,
                function () {
                    if (originalColor) {
                        sphere.scaling = new BABYLON.Vector3(0.04, 0.04, 0.04);
                        sphere.material.diffuseColor = originalColor.clone();
                        originalColor = null;
                        document.body.style.cursor = "default";
                        rect.isVisible = false;
                    }
                }
            )
        );

        // ðŸ–±ï¸ Action au clic : ouvrir un lien dans un nouvel onglet
        sphere.actionManager.registerAction(
            new BABYLON.ExecuteCodeAction(
                BABYLON.ActionManager.OnPickTrigger,
                function () {
                    window.open("articles/neige_quebec.html", "_blank");
                }
            )
        );





        // tornade


        const actionManagert = new BABYLON.ActionManager(scene);
        Cone.actionManager = actionManagert;

        // ðŸŒŸ Effet visuel au survol
        let originalColort = null;
        Cone.actionManager.registerAction(
            new BABYLON.ExecuteCodeAction(
                BABYLON.ActionManager.OnPointerOverTrigger,
                function () {
                    if (Cone.material && !originalColort) {
                        Cone.scaling = new BABYLON.Vector3(0.2, 0.05, 0.2);
                        originalColort = Cone.material.diffuseColor.clone();
                        Cone.material.diffuseColor = new BABYLON.Color3(1, 0.5, 0.1); // orange sur survol
                        document.body.style.cursor = "pointer"; // curseur main
                        rectt.isVisible = true;
                    }
                }
            )
        );

        // ðŸ”„ Retour Ã  la couleur dâ€™origine quand on quitte
        Cone.actionManager.registerAction(
            new BABYLON.ExecuteCodeAction(
                BABYLON.ActionManager.OnPointerOutTrigger,
                function () {
                    if (originalColort) {
                        Cone.scaling = new BABYLON.Vector3(0.17, 0.05, 0.17);
                        Cone.material.diffuseColor = originalColort.clone();
                        originalColort = null;
                        document.body.style.cursor = "default";
                        rectt.isVisible = false;
                    }
                }
            )
        );

        // ðŸ–±ï¸ Action au clic : ouvrir un lien dans un nouvel onglet
        Cone.actionManager.registerAction(
            new BABYLON.ExecuteCodeAction(
                BABYLON.ActionManager.OnPickTrigger,
                function () {
                    window.open("articles/ouragan_melissa.html", "_blank");
                }
            )
        );

        // flch


        const actionManagerf = new BABYLON.ActionManager(scene);
        flch.actionManager = actionManagerf;

        // ðŸŒŸ Effet visuel au survol
        let originalColorf = null;
        flch.actionManager.registerAction(
            new BABYLON.ExecuteCodeAction(
                BABYLON.ActionManager.OnPointerOverTrigger,
                function () {
                    if (flch.material && !originalColorf) {
                        flch.scaling = new BABYLON.Vector3(0.045, 0.045, 0.045);
                        originalColorf = flch.material.diffuseColor.clone();
                        flch.material.diffuseColor = new BABYLON.Color3(1, 0.5, 0.1); // orange sur survol
                        document.body.style.cursor = "pointer"; // curseur main
                        rectf.isVisible = true;
                    }
                }
            )
        );

        // ðŸ”„ Retour Ã  la couleur dâ€™origine quand on quitte
        flch.actionManager.registerAction(
            new BABYLON.ExecuteCodeAction(
                BABYLON.ActionManager.OnPointerOutTrigger,
                function () {
                    if (originalColorf) {
                        flch.scaling = new BABYLON.Vector3(0.04, 0.04, 0.04);
                        flch.material.diffuseColor = originalColorf.clone();
                        originalColorf = null;
                        document.body.style.cursor = "default";
                        rectf.isVisible = false;
                    }
                }
            )
        );

        // ðŸ–±ï¸ Action au clic : ouvrir un lien dans un nouvel onglet
        flch.actionManager.registerAction(
            new BABYLON.ExecuteCodeAction(
                BABYLON.ActionManager.OnPickTrigger,
                function () {
                    window.open("articles/pressionAcmos.html", "_blank");
                }
            )
        );



        return scene;
    };

    createScene().then((scene) => {
        engine.runRenderLoop(() => {
            scene.render();
        });
    });



    window.addEventListener("resize", () => engine.resize());
</script>
</body>
</html>
